[
  {
    "objectID": "index.html#motivation",
    "href": "index.html#motivation",
    "title": "Automatic Differentiation",
    "section": "Motivation",
    "text": "Motivation\n\n\n\n\n\n\nWhat is a derivative?\n\n\nA linear map \\(\\partial f(x)\\) approximating a function around a point \\(x\\):\n\\[f(x + v) = f(x) + \\partial f(x)[v]\n+ o(\\lVert v \\rVert)\\]\n\n\n\n\n\n\n\n\n\nWhy do we care?\n\n\nDerivatives of computer code are essential in optimization and machine learning.\n\n\n\n\n\n\n\n\n\nWhat do I need to do?\n\n\nNot much: with Automatic Differentiation (AD), derivatives are easy to compute!"
  },
  {
    "objectID": "index.html#python-vs.-julia-users",
    "href": "index.html#python-vs.-julia-users",
    "title": "Automatic Differentiation",
    "section": "Python vs. Julia: users",
    "text": "Python vs. Julia: users\n\nImage: courtesy of Adrian Hill"
  },
  {
    "objectID": "index.html#python-vs.-julia-developers",
    "href": "index.html#python-vs.-julia-developers",
    "title": "Automatic Differentiation",
    "section": "Python vs. Julia: developers",
    "text": "Python vs. Julia: developers\n\nImage: courtesy of Adrian Hill"
  },
  {
    "objectID": "index.html#various-flavors-of-differentiation",
    "href": "index.html#various-flavors-of-differentiation",
    "title": "Automatic Differentiation",
    "section": "Various flavors of differentiation",
    "text": "Various flavors of differentiation\n\nManual: work out \\(\\partial f\\) by hand\nNumeric: \\(\\partial f(x)[v] \\approx \\frac{f(x+\\varepsilon v) - f(x)}{\\varepsilon}\\)\nSymbolic: code a formula for \\(f\\), get a formula for \\(\\partial f\\)\nAutomatic: code a program for \\(f\\), get a program for \\(\\partial f(x)\\)"
  },
  {
    "objectID": "index.html#automatic-differentiation",
    "href": "index.html#automatic-differentiation",
    "title": "Automatic Differentiation",
    "section": "Automatic differentiation",
    "text": "Automatic differentiation\nThree key ideas (Griewank and Walther 2008):\n\nPrograms are compositions of many functions\nDifferential of \\(f = g \\circ h\\) is given by the chain rule: \\[\\partial f(x) = \\partial g(h(x)) \\circ \\partial h(x)\\]\nThink in terms of linear maps, not Jacobian matrices \\[\\partial f(x)[v] = \\partial g(h(x))[\\underbrace{\\partial h(x)[v]}_w]\\]"
  },
  {
    "objectID": "index.html#why-so-many-backends",
    "href": "index.html#why-so-many-backends",
    "title": "Automatic Differentiation",
    "section": "Why so many backends?",
    "text": "Why so many backends?\n\nConflicting paradigms:\n\nnumeric vs. symbolic vs. algorithmic\noperator overloading vs. source-to-source\n\nCover varying subsets of the language\nHistorical reasons: developed by different people"
  },
  {
    "objectID": "index.html#meaningful-criteria",
    "href": "index.html#meaningful-criteria",
    "title": "Automatic Differentiation",
    "section": "Meaningful criteria",
    "text": "Meaningful criteria\n\nDoes this AD backend execute without error?\nDoes it return the right derivative?\nDoes it run fast enough for me?"
  },
  {
    "objectID": "index.html#a-simple-decision-tree",
    "href": "index.html#a-simple-decision-tree",
    "title": "Automatic Differentiation",
    "section": "A simple decision tree",
    "text": "A simple decision tree\n\nFollow recommendations of high-level library (e.g. Flux).\nOtherwise, choose mode from input/output dimensions.\nTry the most battle-tested backends:\n\nForwardDiff or Enzyme in forward mode,\nZygote or Enzyme in reverse mode.\n\nIf nothing works, fall back on finite differences."
  },
  {
    "objectID": "index.html#typical-forwarddiff-failure",
    "href": "index.html#typical-forwarddiff-failure",
    "title": "Automatic Differentiation",
    "section": "Typical ForwardDiff failure",
    "text": "Typical ForwardDiff failure\n\nimport ForwardDiff\n\nbadcopy(x) = copyto!(zeros(size(x)), x)\n\nForwardDiff.jacobian(badcopy, ones(2))\n\nMethodError: MethodError(Float64, (Dual{ForwardDiff.Tag{typeof(Main.Notebook.badcopy), Float64}}(1.0,1.0,0.0),), 0x0000000000007b07)\nMethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n\nClosest candidates are:\n  (::Type{T})(::Real, !Matched::RoundingMode) where T&lt;:AbstractFloat\n   @ Base rounding.jl:207\n  (::Type{T})(::T) where T&lt;:Number\n   @ Core boot.jl:792\n  Float64(!Matched::IrrationalConstants.Halfπ)\n   @ IrrationalConstants ~/.julia/packages/IrrationalConstants/vp5v4/src/macro.jl:112\n  ...\n\nStacktrace:\n  [1] convert(::Type{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2})\n    @ Base ./number.jl:7\n  [2] setindex!(A::Vector{Float64}, x::ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}, i1::Int64)\n    @ Base ./array.jl:1021\n  [3] _unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}, soffs::Int64, n::Int64)\n    @ Base ./array.jl:299\n  [4] unsafe_copyto!\n    @ ./array.jl:353 [inlined]\n  [5] _copyto_impl!\n    @ ./array.jl:376 [inlined]\n  [6] copyto!\n    @ ./array.jl:363 [inlined]\n  [7] copyto!\n    @ ./array.jl:385 [inlined]\n  [8] badcopy(x::Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}})\n    @ Main.Notebook ~/work/JuliaOptimizationDays2024-AutoDiff/JuliaOptimizationDays2024-AutoDiff/index.qmd:126\n  [9] vector_mode_dual_eval!\n    @ ~/.julia/packages/ForwardDiff/PcZ48/src/apiutils.jl:24 [inlined]\n [10] vector_mode_jacobian(f::typeof(badcopy), x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:125\n [11] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}}, ::Val{true})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:21\n [12] jacobian(f::Function, x::Vector{Float64}, cfg::ForwardDiff.JacobianConfig{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2, Vector{ForwardDiff.Dual{ForwardDiff.Tag{typeof(badcopy), Float64}, Float64, 2}}})\n    @ ForwardDiff ~/.julia/packages/ForwardDiff/PcZ48/src/jacobian.jl:19\n [13] top-level scope\n    @ ~/work/JuliaOptimizationDays2024-AutoDiff/JuliaOptimizationDays2024-AutoDiff/index.qmd:128"
  },
  {
    "objectID": "index.html#forwarddiff-troubleshooting",
    "href": "index.html#forwarddiff-troubleshooting",
    "title": "Automatic Differentiation",
    "section": "ForwardDiff troubleshooting",
    "text": "ForwardDiff troubleshooting\nAllow numbers of type Dual in your functions.\n\ngoodcopy(x::AbstractArray{&lt;:Real}) = copyto!(zeros(eltype(x), size(x)), x)\n\nForwardDiff.jacobian(goodcopy, ones(2))\n\n2×2 Matrix{Float64}:\n 1.0  0.0\n 0.0  1.0"
  },
  {
    "objectID": "index.html#typical-zygote-failure",
    "href": "index.html#typical-zygote-failure",
    "title": "Automatic Differentiation",
    "section": "Typical Zygote failure",
    "text": "Typical Zygote failure\n\nimport Zygote\n\nZygote.jacobian(badcopy, ones(2))\n\nErrorException: ErrorException(\"Mutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\\nThis error occurs when you ask Zygote to differentiate operations that change\\nthe elements of arrays in place (e.g. setting values with x .= ...)\\n\\nPossible fixes:\\n- avoid mutating operations (preferred)\\n- or read the documentation and solutions for this error\\n  https://fluxml.ai/Zygote.jl/latest/limitations\\n\")\nMutating arrays is not supported -- called copyto!(Vector{Float64}, ...)\nThis error occurs when you ask Zygote to differentiate operations that change\nthe elements of arrays in place (e.g. setting values with x .= ...)\n\nPossible fixes:\n- avoid mutating operations (preferred)\n- or read the documentation and solutions for this error\n  https://fluxml.ai/Zygote.jl/latest/limitations\n\nStacktrace:\n  [1] error(s::String)\n    @ Base ./error.jl:35\n  [2] _throw_mutation_error(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/lib/array.jl:70\n  [3] (::Zygote.var\"#547#548\"{Vector{Float64}})(::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/lib/array.jl:85\n  [4] (::Zygote.var\"#2633#back#549\"{Zygote.var\"#547#548\"{Vector{Float64}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [5] badcopy\n    @ ~/work/JuliaOptimizationDays2024-AutoDiff/JuliaOptimizationDays2024-AutoDiff/index.qmd:126 [inlined]\n  [6] (::Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#549\"{Zygote.var\"#547#548\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/compiler/interface2.jl:0\n  [7] (::Zygote.var\"#294#295\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#549\"{Zygote.var\"#547#548\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/lib/lib.jl:206\n  [8] (::Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing}}, Zygote.Pullback{Tuple{typeof(badcopy), Vector{Float64}}, Tuple{Zygote.var\"#2633#back#549\"{Zygote.var\"#547#548\"{Vector{Float64}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}, Zygote.ZBack{Returns{Tuple{ChainRulesCore.NoTangent, ChainRulesCore.NoTangent}}}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72\n  [9] call_composed\n    @ ./operators.jl:1045 [inlined]\n [10] (::Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/compiler/interface2.jl:0\n [11] call_composed\n    @ ./operators.jl:1044 [inlined]\n [12] #_#103\n    @ ./operators.jl:1041 [inlined]\n [13] (::Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#207\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#216\"{Zygote.var\"#back#214\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#284\"{Zygote.var\"#280#283\"}}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/compiler/interface2.jl:0\n [14] #294\n    @ ~/.julia/packages/Zygote/NRp5C/src/lib/lib.jl:206 [inlined]\n [15] #2169#back\n    @ ~/.julia/packages/ZygoteRules/M4xmc/src/adjoint.jl:72 [inlined]\n [16] ComposedFunction\n    @ ./operators.jl:1041 [inlined]\n [17] (::Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2366#back#423\"{Zygote.var\"#pairs_namedtuple_pullback#422\"{(), @NamedTuple{}}}, Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#207\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#216\"{Zygote.var\"#back#214\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#284\"{Zygote.var\"#280#283\"}}}}}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#207\"{typeof(identity)}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/compiler/interface2.jl:0\n [18] (::Zygote.var\"#78#79\"{Zygote.Pullback{Tuple{ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.var\"#2366#back#423\"{Zygote.var\"#pairs_namedtuple_pullback#422\"{(), @NamedTuple{}}}, Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing, Nothing}, Tuple{Nothing}}, Zygote.Pullback{Tuple{Base.var\"##_#103\", @Kwargs{}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}}, Tuple{Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:outer, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(badcopy)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(badcopy)}, Tuple{}}}}, Zygote.var\"#2180#back#306\"{Zygote.var\"#back#305\"{:inner, Zygote.Context{false}, ComposedFunction{typeof(Zygote._jvec), typeof(badcopy)}, typeof(badcopy)}}, Zygote.var\"#2169#back#296\"{Zygote.var\"#294#295\"{Tuple{Tuple{Nothing}, Tuple{Nothing}}, Zygote.var\"#2013#back#207\"{typeof(identity)}}}, Zygote.Pullback{Tuple{typeof(Base.unwrap_composed), typeof(Zygote._jvec)}, Tuple{Zygote.var\"#2013#back#207\"{typeof(identity)}, Zygote.Pullback{Tuple{typeof(Base.maybeconstructor), typeof(Zygote._jvec)}, Tuple{}}}}}}, Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(Zygote._jvec), typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Tuple{Zygote.Pullback{Tuple{typeof(Base.call_composed), Tuple{typeof(badcopy)}, Tuple{Vector{Float64}}, @Kwargs{}}, Any}, Zygote.var\"#2029#back#216\"{Zygote.var\"#back#214\"{2, 1, Zygote.Context{false}, typeof(Zygote._jvec)}}, Zygote.Pullback{Tuple{typeof(Zygote._jvec), Vector{Float64}}, Tuple{Zygote.Pullback{Tuple{typeof(vec), Vector{Float64}}, Tuple{}}}}, Zygote.var\"#2141#back#284\"{Zygote.var\"#280#283\"}}}}}}}, Zygote.Pullback{Tuple{Type{NamedTuple}}, Tuple{}}, Zygote.var\"#2013#back#207\"{typeof(identity)}}}})(Δ::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/compiler/interface.jl:91\n [19] withjacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/lib/grad.jl:150\n [20] jacobian(f::Function, args::Vector{Float64})\n    @ Zygote ~/.julia/packages/Zygote/NRp5C/src/lib/grad.jl:128\n [21] top-level scope\n    @ ~/work/JuliaOptimizationDays2024-AutoDiff/JuliaOptimizationDays2024-AutoDiff/index.qmd:154"
  },
  {
    "objectID": "index.html#zygote-troubleshooting",
    "href": "index.html#zygote-troubleshooting",
    "title": "Automatic Differentiation",
    "section": "Zygote troubleshooting",
    "text": "Zygote troubleshooting\nDefine a custom rule with ChainRulesCore:\n\nusing ChainRulesCore, LinearAlgebra\n\nbadcopy2(x) = badcopy(x)\n\nfunction ChainRulesCore.rrule(::typeof(badcopy2), x)\n    @info \"My rule is called\"\n    y = badcopy2(x)  # primal value\n    function badcopy2_pullback(dy)\n    @info \"My pullback is called\"\n        df = NoTangent()\n        dx = I' * dy # Vector-Jacobian product\n        return (df, dx)\n    end\n    return y, badcopy2_pullback\nend\n\nZygote.jacobian(badcopy2, ones(2))\n\n[ Info: My rule is called\n[ Info: My pullback is called\n[ Info: My pullback is called\n\n\n([1.0 0.0; 0.0 1.0],)"
  },
  {
    "objectID": "index.html#typical-enzyme-failure",
    "href": "index.html#typical-enzyme-failure",
    "title": "Automatic Differentiation",
    "section": "Typical Enzyme failure",
    "text": "Typical Enzyme failure\n\nimport Enzyme\n\nEnzyme.autodiff(\n  Enzyme.Forward,\n  badcopy,\n  Enzyme.Active(ones(2))\n)\n\nErrorException: ErrorException(\"Unsupported Active{Vector{Float64}}, consider Duplicated or Const\")\nUnsupported Active{Vector{Float64}}, consider Duplicated or Const\nStacktrace:\n [1] error(s::String)\n   @ Base ./error.jl:35\n [2] EnzymeCore.Active(x::Vector{Float64})\n   @ EnzymeCore ~/.julia/packages/EnzymeCore/frpza/src/EnzymeCore.jl:50\n [3] top-level scope\n   @ ~/work/JuliaOptimizationDays2024-AutoDiff/JuliaOptimizationDays2024-AutoDiff/index.qmd:194"
  },
  {
    "objectID": "index.html#enzyme-troubleshooting",
    "href": "index.html#enzyme-troubleshooting",
    "title": "Automatic Differentiation",
    "section": "Enzyme troubleshooting",
    "text": "Enzyme troubleshooting\nPay attention to type stability, temporary storage and activity annotations (see the FAQ).\nEnzyme.autodiff(\n  Enzyme.Forward,\n  badcopy,\n  Enzyme.Duplicated(ones(2), zeros(2))\n)"
  },
  {
    "objectID": "index.html#references",
    "href": "index.html#references",
    "title": "Automatic Differentiation",
    "section": "References",
    "text": "References\n\n\nGriewank, Andreas, and Andrea Walther. 2008. Evaluating Derivatives: Principles and Techniques of Algorithmic Differentiation. 2nd ed. Philadelphia, PA: Society for Industrial and Applied Mathematics."
  }
]